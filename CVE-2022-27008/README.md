- related links
  - https://github.com/nginx/njs/issues/471
  - https://nvd.nist.gov/vuln/detail/cve-2022-27008
  - https://github.com/nginx/njs/commit/e673ae41a998d1391bd562edb2ed6d49db7cc716

## Cause

`njs` expected the `this` array should be a fast array either when the appended element was a fast array. However, `this` array was not always a fast form. When it was converted into a slow array in `njs_array_convert_to_slow_array()`, the field `start` was set to `NULL`, thus memory crashed:

```c
/// njs_array_convert_to_slow_array()

  // ...
  array->object.fast_array = 0;
  // ...
  /* GC: release value. */
  njs_mp_free(vm->mem_pool, array->start);
  array->start = NULL;
  // ...
```

```c
/// njs_array_add()
  // ...
  if (njs_fast_path(ret == NJS_OK)) {
    /* GC: retain value. */
    array->start[array->length++] = *value; // VULNE: array->start is NULL
  }
  // ...
```

The conversion was implicit during a long invokation chain while the variable `array` itself was a member of union `njs_value_t.data`, which improved the complexity to analyse.

```c
// njs_array_prototype_concat()
njs_value_t value; // original variable defined here
njs_array_t *array = value->data.u.array;

// njs_array_prototype_concat()
//  -> njs_value_property_i64_set(.., value, ..)
//  -> njs_value_property_set(.., value, ..)
//  -> njs_property_query(.., value, ..)
njs_object_t *obj = &array->object;  // object is the first member of array, thus (void*)array == (void*)&array->object

// njs_property_query(.., value, ..)
//  -> njs_object_property_query(.., obj, ..)
njs_object_t *proto = obj;
njs_array_t *array = (njs_array_t *)proto; // force cast here

// njs_object_property_query(.., obj, ..)
//  -> njs_array_property_query(.., array, ..)
//  -> njs_array_convert_to_slow_array(.., array, ..)
array->start = NULL;

// njs_array_prototype_concat()
//  -> njs_array_add(.., array, ..)
array->start[array->length++] = *value; // SEGV occurs
```

The [patch](https://github.com/nginx/njs/commit/e673ae41a998d1391bd562edb2ed6d49db7cc716) fixed this issue by invoking `njs_value_property_i64_set()` instead of `njs_array_add()`.

## Root cause

CSA can not detect this vulnerability because

The data structure is very complex which contains unions and special type casts so that CSA cannot detect that two different pointers are pointing to the same data.
